#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""AAsap: Amino Acid Sequence Analysis Pipeline
About:
    This is the main entry for the AAsap pipeline.
USAGE:
	$ aasap <build> [OPTIONS]
Example:
    $ aasap build -h
"""

from __future__ import print_function
from src.utils import (initialize, 
    fatal,
    err,
    require,
    permissions) 
import sys, os, json, subprocess
import argparse, textwrap

__author__ = 'Skyler Kuhn'
__version__ = 'v0.1.0'
__email__ = 'kuhnsa@nih.gov'


def bash(cmd, interpreter='/bin/bash', strict=True, **kwargs):
    """
    Interface to run a process or bash command. Using subprocess.call_check()
    due to portability across most python versions. It was introduced in python 2.5
    and it is also interoperabie across all python 3 versions. 
    @param cmd <str>:
        Shell command to run
    @param interpreter <str>:
        Interpreter for command to run [default: bash]
    @pararm strict <bool>:
        Prefixes any command with 'set -euo pipefail' to ensure process fail with
        the expected exit-code  
    @params kwargs <check_call()>:
        Keyword arguments to modify subprocess.check_call() behavior
    @return exitcode <int>:
        Returns the exit code of the run command, failures return non-zero exit codes
    """
    # Changes behavior of default shell
    prefix = ''
    # set -e: exit immediately upon error
    # set -u: treats unset variables as an error
    # set -o pipefail: exits if a error occurs in any point of a pipeline
    if strict: prefix = 'set -euo pipefail; '

    exitcode = subprocess.check_call(prefix + cmd, shell = True, executable = interpreter, **kwargs)

    if exitcode != 0: 
        fatal("""\n\tFatal: Failed to run '{}' command!
        └── Command returned a non-zero exitcode of '{}'.
        """.format(process, exitcode)
        )

    return exitcode


def build(sub_args):
    """Builds the reference files for the AAsap pipeline from a genomic FASTA
    file and a GTF file. Disclaimer: hybrid genomes not supported.
    @param sub_args <parser.parse_args() object>:
        Parsed arguments for unlock sub-command
    """
    # Initialize the output directory
    initialize(sub_args.output, links=[sub_args.ref_fa, sub_args.ref_gtf])
    
    # Check for required runtime dependencies
    # Build command needs samtools and gffread from cufflinks package
    require(cmds=["samtools", "gffread"], suggestions=["samtools", "cufflinks"])
    
    # Build Index for the Genomic FASTA file
    # samtools faidx ref.fa -fai-idx /path/to/ref.fa.fai
    process = "samtools faidx {} --fai-idx {}.fai".format(
        sub_args.ref_fa, 
        os.path.join(sub_args.output, os.path.basename(sub_args.ref_fa))
    )

    print("Running: " + process)
    exitcode = bash(process)

    # Extract transcript sequences from reference FASTA file and GTF file
    # gffread -F -w /path/to/transcripts.fa -g genome.fa transcripts.gtf
    process = "gffread -F -w {} -g {} {}".format(
        os.path.join(sub_args.output, "transcripts.fa"),
        os.path.join(sub_args.output, os.path.basename(sub_args.ref_fa)),
        os.path.join(sub_args.output, os.path.basename(sub_args.ref_gtf))
    )

    print("Running: " + process)
    exitcode = bash(process)


def parsed_arguments():
    """Parses user-provided command-line arguments. Requires argparse and textwrap
    package. argparse was added to standard lib in python 3.2 and textwrap was added
    in python 3.5. To create custom help formatting for subparsers a docstring is
    used create the help message for required options. argparse does not support named
    subparser groups, which is normally what would be used to accomphish this reformatting.
    As so, the help message for require options must be suppressed. If a new required arg
    is added to a subparser, it must be added to the docstring and the usage statement
    also must be updated.
    """

    # Create a top-level parser
    parser = argparse.ArgumentParser(description = 'AAsap: \
                                                    Amino Acid Sequence Analysis Pipeline')

    # Adding Verison information
    parser.add_argument('--version', action = 'version', version='%(prog)s {}'.format(__version__))

    # Create sub-command parser
    subparsers = parser.add_subparsers(help='List of available sub-commands')
    
    # Options for the "build" sub-command
    # Grouped sub-parser arguments are currently not supported.
    # https://bugs.python.org/issue9341
    # Here is a work around to create more useful help message for named
    # options that are required! Please note: if a required arg is added the
    # description below should be updated (i.e. update usage and add new option)
    required_build_options = textwrap.dedent("""\
        usage: aasap build [-h] --ref-fa REF_FA 
                                --ref-gtf REF_GTF
                                --output OUTPUT

        Builds the reference files for the AAsap pipeline from a genomic
        FASTA file and a GTF file. Disclaimer: If you have two GTF files,
        eg. hybrid genomes (viral + host), then you need to create one 
        FASTA and one GTF file for the hybrid genome prior to running 
        the aasap build command.

        required arguments:
          --ref-fa REF_FA       Genomic FASTA file of the reference genome.

          --ref-gtf REF_GTF     GTF file for the reference genome.

          --output OUTPUT       Path to an output directory. This path
                                is where the pipeline will create all 
                                of its output files. If the provided 
                                output directory does not exist, it 
                                will be created.
        """)

    # Display example usage in epilog
    build_epilog = textwrap.dedent("""\
        example:
          # Step 1.) Grab an interactive node (do not run on head node)
          sinteractive --mem=8g --cpus-per-task=4
          module purge
          module load cuffdiff samtools

          # Step 2.) Build AAsap reference files
          aasap build --ref-fa GRCm39.primary_assembly.genome.fa \\
                      --ref-gtf gencode.vM26.annotation.gtf \\
                      --output /scratch/$USER/AASAP/refs/

        version:
          {}
        """.format(__version__))

    # Supressing help message of required args to overcome no sub-parser named groups
    subparser_build = subparsers.add_parser('build',
                                            help = 'Builds the reference files for the AAsap.',
                                            usage = argparse.SUPPRESS,
                                            formatter_class=argparse.RawDescriptionHelpFormatter,
                                            description = required_build_options,
                                            epilog = build_epilog)
    # Input Genomic FASTA file
    subparser_build.add_argument('--ref-fa',
                                # Check if the file exists and if it is readable
                                type = lambda file: permissions(parser, file, os.R_OK),
                                required = True,
                                help = argparse.SUPPRESS)
    # Input Reference GTF file
    subparser_build.add_argument('--ref-gtf',
                                # Check if the file exists and if it is readable
                                type = lambda file: permissions(parser, file, os.R_OK),
                                required = True,
                                help = argparse.SUPPRESS)
    # Output Directory (build working directory)
    subparser_build.add_argument('--output',
                                type = lambda option: os.path.abspath(os.path.expanduser(option)),
                                required = True,
                                help = argparse.SUPPRESS)

    # Define handlers for each sub-parser
    subparser_build.set_defaults(func = build)

    # Parse command-line args
    args = parser.parse_args()
    return args


def main():

    # Collect args for sub-command
    args = parsed_arguments()

    # Display version information
    print('AAsap ({})'.format(__version__))

    # Mediator method to call sub-command's set handler function
    args.func(args)


if __name__ == '__main__':
    main()