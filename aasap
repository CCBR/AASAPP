#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""AASAP: Amino Acid Sequence Analysis Pipeline
About:
    This is the main entry for the AASAP pipeline.
USAGE:
	$ aasap <build|run> [OPTIONS]
Example:
    $ aasap build -h
    $ aasap run -h
"""

from __future__ import print_function
from src.utils import (initialize, 
    fatal,
    err,
    require,
    permissions) 
from src.mutator import (mutate,
    NonCodingVariantError,
    UnsupportedVariantTypeError,
    VariantParsingError,
    NonMatchingReferenceBases)
from src.aminoacid import (translate,
    convert_aa_cooridate,
    truncate,
    InvalidCodonError)
from src.reader import (fasta, 
    excel,
    tsv,
    csv,
    maf)
import sys, os, subprocess
import argparse, textwrap

__author__ = 'Skyler Kuhn'
__version__ = 'v1.2.1'
__email__ = 'kuhnsa@nih.gov'


def bash(cmd, interpreter='/bin/bash', strict=True, **kwargs):
    """
    Interface to run a process or bash command. Using subprocess.call_check()
    due to portability across most python versions. It was introduced in python 2.5
    and it is also interoperabie across all python 3 versions. 
    @param cmd <str>:
        Shell command to run
    @param interpreter <str>:
        Interpreter for command to run [default: bash]
    @pararm strict <bool>:
        Prefixes any command with 'set -euo pipefail' to ensure process fail with
        the expected exit-code  
    @params kwargs <check_call()>:
        Keyword arguments to modify subprocess.check_call() behavior
    @return exitcode <int>:
        Returns the exit code of the run command, failures return non-zero exit codes
    """
    # Changes behavior of default shell
    prefix = ''
    # set -e: exit immediately upon error
    # set -u: treats unset variables as an error
    # set -o pipefail: exits if a error occurs in any point of a pipeline
    if strict: prefix = 'set -euo pipefail; '

    exitcode = subprocess.check_call(prefix + cmd, shell = True, executable = interpreter, **kwargs)

    if exitcode != 0: 
        fatal("""\n\tFatal: Failed to run '{}' command!
        └── Command returned a non-zero exitcode of '{}'.
        """.format(process, exitcode)
        )

    return exitcode


def build(sub_args):
    """Builds the reference files for the AAsap pipeline from a genomic FASTA
    file and a GTF file. Disclaimer: hybrid genomes not supported.
    @param sub_args <parser.parse_args() object>:
        Parsed arguments for build sub-command
    """
    # Initialize the output directory
    initialize(sub_args.output, links=[sub_args.ref_fa, sub_args.ref_gtf])
    
    # Check for required runtime dependencies
    # Build command needs samtools and gffread from cufflinks package
    require(cmds=["samtools", "gffread"], suggestions=["samtools", "cufflinks"])
    
    # Build Index for the Genomic FASTA file
    # samtools faidx ref.fa -fai-idx /path/to/ref.fa.fai
    process = "samtools faidx {} --fai-idx {}.fai".format(
        sub_args.ref_fa, 
        os.path.join(sub_args.output, os.path.basename(sub_args.ref_fa))
    )

    print("Running: " + process)
    exitcode = bash(process)

    # Extract transcript CDS sequences from reference FASTA file and GTF file
    # gffread -F -x /path/to/transcripts.fa -g genome.fa transcripts.gtf
    process = "gffread -F -x {} -g {} {}".format(
        os.path.join(sub_args.output, "transcripts.fa"),
        os.path.join(sub_args.output, os.path.basename(sub_args.ref_fa)),
        os.path.join(sub_args.output, os.path.basename(sub_args.ref_gtf))
    )

    print("Running: " + process)
    exitcode = bash(process)


def run(sub_args):
    """Runs the Amino Acid sequence analysis pipeline to determine 
    the consequence of a mutation on a protein product. Obtains the 
    mutated amino acid sequence for a given variant.
    @param sub_args <parser.parse_args() object>:
        Parsed arguments for run sub-command
    """
    # Initialize the output directory
    initialize(sub_args.output)
    # Truncates non-frame shift mutations 
    # +/- N positions from mutation start 
    # site in the amino acid sequence
    subset = int(sub_args.subset)
    # Dictionary to quickly map each 
    # transcript ID to its coding DNA
    # sequence or CDS sequence. The 
    # build coomand can be used to 
    # generate this reference file.
    transcriptome = {}
    for sid, sequence in fasta(sub_args.transcripts):
        # Grab the transcipt id and remove the version suffix
        transcript_id = sid.split(' ')[0].split('.')[0]
        transcriptome[transcript_id] = sequence

    # Run AASAP against each user supplied input file 
    for file in sub_args.input:
        # Parse field of interest from each 
        # excel file. Each input file is 
        # required have the following fields:
        # 'Transcript_ID', 'Variant_Classification',
        # 'HGVSc', 'Hugo_Symbol' where 'Transcript_ID'
        # and 'Variant_Classification','HGVSc' are 
        # mandatory.
        err('Opening {}'.format(file))
        # Handler for reading in MAF-like files in
        # different file formats and/or using different 
        # delimeters (like comma versus tab).
        # Defaults to TSV reader which is the 
        # most common file type for MAF or 
        # VCF files if the file does not have
        # an excel-like file extension or 
        # a CSV-like file extension.
        df = maf(file, subset=['Transcript_ID','Variant_Classification','HGVSc','Hugo_Symbol','Gene'])
        # Create output file name from input file
        # Output file name generated by removing the
        # suffix or input file name extension and 
        # adding a new extension '.aasap.tsv' 
        output_file = os.path.join(sub_args.output, "{}.aasap.tsv".format(os.path.splitext(os.path.basename(file))[0]))
        err('Writing output file {}'.format(output_file))
        with open(output_file, 'w') as ofh:
            # Write header to output file
            ofh.write("{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\n".format(
                "Variant_Classification", 
                "Hugo_Symbol", 
                "Transcript_ID", 
                "HGVSc", 
                "Variant_Start_Position", 
                "WT_Transcript_Sequence",
                "Mutated_Transcript_Sequence", 
                "WT_AA_Sequence",
                "Mutated_AA_Sequence", 
                "WT_Subset_AA_Sequence",
                "Mutated_Subset_AA_Sequence"))

            # Mutate each recorded variant in the input file. 
            for i,row in df.iterrows():
                # Variant class is used to determine the size 
                # of the downstream portion of the subset AA
                # sequence from the variant start site. Frame
                # shift mutations will report until the end of 
                # the coding AA sequence or until a stop codon 
                # is reached.
                variant_class = str(row['Variant_Classification'])
                transcript = str(row['Transcript_ID'])
                hgvs = str(row['HGVSc'])
                hugo = str(row['Hugo_Symbol'])
                if (hgvs and hgvs != 'nan') and (transcript and transcript != 'nan') and (variant_class and variant_class != 'nan'):
                    try:
                        sequence = transcriptome[transcript]
                    except KeyError:
                        # Skip over un-annotated transcript.
                        # Recorded transcript is not annotated
                        # in the user provided reference file,
                        # which may indicate that the user did 
                        # not provide the same reference files
                        # to call variants and to generate the 
                        # MAF file in the build sub command
                        err("{} {}".format("WARNING: Transcript {} not found in provided transcripts FASTA file!".format(transcript),
                        "Please verify the correct reference file is provided!"))
                        continue
                    try:
                        # Mutate the coding DNA sequence based on
                        # the recorded HGVS representation of the 
                        # mutation, and get the mutation start site.
                        # HGVS terms representing mutations in non-exonic 
                        # regions will return a NonCodingVariantError. 
                        # HGVS terms without a parser or HGVS terms which 
                        # are not supported will return a 
                        # UnsupportedVariantTypeError.
                        # HGVS terms which cannot be parsed during term
                        # tokenization will return a VariantParsingError.
                        # HGVS terms containing the variants reference 
                        # sequence will be checked against the transcripts
                        # sequence. If the transcript sequence does not 
                        # match the HGVS term sequence then a 
                        # NonMatchingReferenceBases error is raised.
                        mutated_dna, variant_position = mutate(sequence, hgvs)
                        # Translate the wt and mutated coding DNA sequence into 
                        # an amino acid sequence. Sequences containing 
                        # codons with non-stardard nucleotide 
                        # representations (i.e. not "A,a,C,c,G,T,t") 
                        # will not be translated and will return  
                        # InvalidCodonError.
                        wt_amino_acid = translate(sequence)
                        mutated_amino_acid = translate(mutated_dna)
                        # Convert coding DNA varaint start site to 
                        # amino acid coordinate system.
                        aa_variant_position = convert_aa_cooridate(variant_position)
                        if variant_class.lower().startswith('frame_shift'):
                            # In the Subset_AA_sequence representation of
                            # the mutated and wt amino acid sequence, the
                            # downstream portion of frameshift mutations
                            # are reported until one of the following
                            # conditions are met: the end of the coding
                            # sequence is reached, OR until the first
                            # terminating stop codon is reached.
                            truncated_wt_aa = truncate(wt_amino_acid, aa_variant_position, subset)
                            truncated_mutated_aa = truncate(mutated_amino_acid, aa_variant_position, subset)
                        else:
                            # In the Subset_AA_sequence representation of
                            # the wt and mutated amino acid sequence, the
                            # upstream and downstream portion of non-frame
                            # shift mutations are +/- N amino acids of the
                            # mutation start site. This vairable is adjustable
                            # via the --subset cli option.
                            truncated_wt_aa = truncate(wt_amino_acid, aa_variant_position, subset, subset)
                            truncated_mutated_aa = truncate(mutated_amino_acid, aa_variant_position, subset, subset)
                        # Write results to output file
                        ofh.write("{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\n".format(variant_class, hugo, transcript, hgvs, variant_position,
                            sequence, mutated_dna, wt_amino_acid, mutated_amino_acid, truncated_wt_aa, truncated_mutated_aa))
                    except NonCodingVariantError as e: 
                        err("WARNING: Skipping over non-coding DNA HGVS variant '{}' reported in {}!".format(hgvs, transcript))
                    except UnsupportedVariantTypeError as e:
                        err("WARNING: Skipping over unsupported HGVS variant class '{}' reported in {}!".format(hgvs, transcript))
                    except VariantParsingError as e:
                        err("WARNING: Skipping over HGVS variant '{}' reported in {} because it could not be parsed!".format(hgvs, transcript))
                    except NonMatchingReferenceBases as e:
                        err("WARNING: Skipping over HGVS variant '{}' reported in {} due to non-matching reference sequence!".format(hgvs, transcript),
                        "Please verify the correct reference file is provided!")
                    except InvalidCodonError as e:
                        err("WARNING: Skipping over HGVS variant '{}' reported in {} due to invalid codon in mutated sequence!".format(hgvs, transcript),
                        "Please review the following mutated coding DNA sequence for any errors:\n\t> {}".format(mutated_dna))


def parsed_arguments():
    """Parses user-provided command-line arguments. Requires argparse and textwrap
    package. argparse was added to standard lib in python 3.2 and textwrap was added
    in python 3.5. To create custom help formatting for subparsers a docstring is
    used create the help message for required options. argparse does not support named
    subparser groups, which is normally what would be used to accomphish this reformatting.
    As so, the help message for require options must be suppressed. If a new required arg
    is added to a subparser, it must be added to the docstring and the usage statement
    also must be updated.
    """

    # Create a top-level parser
    parser = argparse.ArgumentParser(description = 'AASAP: \
                                                    Amino Acid Sequence Analysis Pipeline')

    # Adding Verison information
    parser.add_argument('--version', action = 'version', version='%(prog)s {}'.format(__version__))

    # Create sub-command parser
    subparsers = parser.add_subparsers(help='List of available sub-commands')
    
    # Options for the "build" sub-command
    # Grouped sub-parser arguments are currently not supported.
    # https://bugs.python.org/issue9341
    # Here is a work around to create more useful help message for named
    # options that are required! Please note: if a required arg is added the
    # description below should be updated (i.e. update usage and add new option)
    required_build_options = textwrap.dedent("""\
        usage: aasap build [-h] --ref-fa REF_FA 
                                --ref-gtf REF_GTF
                                --output OUTPUT

        Builds reference files for the Amino Acid sequence analysis pipeline 
        from a genomic FASTA file and an annotation in GTF format. The build 
        sub command creates a FASTA file containing the sequence of each 
        transcript. 

        required arguments:
          --ref-fa REF_FA       Genomic FASTA file of the reference genome.

          --ref-gtf REF_GTF     GTF file for the reference genome.

          --output OUTPUT       Path to an output directory. This path
                                is where the pipeline will create all 
                                of its output files. If the provided 
                                output directory does not exist, it 
                                will be created. After the build sub
                                command completes, the transcripts.fa 
                                transcriptomic FASTA file can be used
                                or supplied to the run sub command.
        """)

    # Display example usage in epilog
    build_epilog = textwrap.dedent("""\
        example:
          # Step 1.) Grab an interactive node (do not run on head node)
          sinteractive --mem=8g --cpus-per-task=4
          module purge
          module load cuffdiff samtools

          # Step 2.) Build AASAP reference files
          aasap build --ref-fa GRCm39.primary_assembly.genome.fa \\
                      --ref-gtf gencode.vM26.annotation.gtf \\
                      --output /scratch/$USER/AASAP/refs/

        version:
          {}
        """.format(__version__))

    # Supressing help message of required args to overcome no sub-parser named groups
    subparser_build = subparsers.add_parser('build',
                                            help = 'Builds the reference files for the AASAP.',
                                            usage = argparse.SUPPRESS,
                                            formatter_class=argparse.RawDescriptionHelpFormatter,
                                            description = required_build_options,
                                            epilog = build_epilog)
    # Input Genomic FASTA file
    subparser_build.add_argument('--ref-fa',
                                # Check if the file exists and if it is readable
                                type = lambda file: permissions(parser, file, os.R_OK),
                                required = True,
                                help = argparse.SUPPRESS)
    # Input Reference GTF file
    subparser_build.add_argument('--ref-gtf',
                                # Check if the file exists and if it is readable
                                type = lambda file: permissions(parser, file, os.R_OK),
                                required = True,
                                help = argparse.SUPPRESS)
    # Output Directory (build working directory)
    subparser_build.add_argument('--output',
                                type = lambda option: os.path.abspath(os.path.expanduser(option)),
                                required = True,
                                help = argparse.SUPPRESS)

    # Options for the "run" sub-command
    # Grouped sub-parser arguments are currently not supported by argparse.
    # https://bugs.python.org/issue9341
    # Here is a work around to create more useful help message for named
    # options that are required! Please note: if a required arg is added the
    # description below should be updated (i.e. update usage and add new option)
    required_run_options = textwrap.dedent("""\
        usage: aasap run [-h] --input INPUT [INPUT ...]
                              --transcripts TRANSCRIPTS
                              --output OUTPUT
                              [--subset SUBSET]

        Runs the Amino Acid sequence analysis pipeline with reference files generated 
        from the build sub command to determine the consequence of a mutation on a 
        protein product. The run sub command takes a VCF-like or MAF-like file and 
        a FASTA file containing transcript sequences. 

        required arguments:
          --input INPUT [INPUT ...]
                           Input VCF-like or MAF-like files to process. One or more 
                           files can be provided. A mutated amino acid sequence will 
                           be generated for each variant in the supplied input file.
                           Example: --input data/*.xlsx
          --transcripts TRANSCRIPTS
                           Transcriptomic FASTA file. This reference file contains 
                           the sequence of each transcript in the reference genome. 
                           The file can be generated by running the build sub command. 
                           When creating this reference file, it is very important to 
                           use the same genomic FASTA and annotation file to call and 
                           annotate variants.
                           Example: --transcripts transcripts.fa 
          --output OUTPUT
                           Path to an output directory. This path is where the pipeline
                           will create all of its output files. If the provided output 
                           directory does not exist, it will be created. 
                           Example: --output /scratch/$USER/AASAP/
        """)

    # Display example usage in epilog
    run_epilog = textwrap.dedent("""\
        example:
          # Step 1.) Grab an interactive node (do not run on head node)
          sinteractive --mem=8g --cpus-per-task=4
          module purge
          module load python/3.5

          # Step 2.) Run AASAP to find mutated protein products
          ./aasap run --input  data/*.xlsx \\
                         --output /scratch/$USER/AASAP \\
                         --transcripts transcripts.fa \\
                         --subset 30

        version:
          {}
        """.format(__version__))

    # Supressing help message of required args to overcome no sub-parser named groups
    subparser_run = subparsers.add_parser('run',
                                            help = 'Run AASAP against called variants.',
                                            usage = argparse.SUPPRESS,
                                            formatter_class=argparse.RawDescriptionHelpFormatter,
                                            description = required_run_options,
                                            epilog  = run_epilog)
    # Input FastQ files
    subparser_run.add_argument('--input',
                                # Check if the file exists and if it is readable
                                type = lambda file: permissions(parser, file, os.R_OK),
                                required = True,
                                nargs = '+',
                                help = argparse.SUPPRESS)
    # Output Directory (analysis working directory)
    subparser_run.add_argument('--output',
                                type = lambda option: os.path.abspath(os.path.expanduser(option)),
                                required = True,
                                help = argparse.SUPPRESS)
    # Reference Transcriptome
    subparser_run.add_argument('--transcripts',
                                # Check if the file exists and if it is readable
                                type = lambda file: permissions(parser, file, os.R_OK),
                                required = True,
                                help = argparse.SUPPRESS)
    # Obtain the mutated amino acid sequence(AAS) +- N amino acids of the mutated amino acid.
    subparser_run.add_argument('--subset',
                                type = int,
                                required = False,
                                default = 30,
                                help = 'Subset resulting mutated amino acid sequence. \
                                        If defined, this option will obtain the mutated \
                                        amino acid sequence (AAS) +/- N amino acids of the mutation \
                                        start site. By default, the first 30 upstream and downstream \
                                        amino acids from the mutation site are recorded for non-frame \
                                        shift mutations. Amino acids downstream of a frame shit mutation \
                                        will be reported until the end of the amino acids sequence for \
                                        the variants transcript or until the first reported terminating \
                                        stop codon is found. \
                                        Example: --subset 30')

    # Sanity check for user command line arguments 
    if len(sys.argv) < 2:
        parser.error("""\n\t └── Fatal: failed to provide a valid sub command to aasap!
             Please run 'aasap  -h' to view more information about aasap's usage.""".format(
                sys.argv[0])
        )

    # Define handlers for each sub-parser
    subparser_build.set_defaults(func = build)
    subparser_run.set_defaults(func = run)

    # Parse command-line args
    args = parser.parse_args()
    return args


def main():

    # Display version information
    print('AASAP ({})'.format(__version__))

    # Collect args for sub-command
    args = parsed_arguments()

    # Mediator method to call sub-command's set handler function
    args.func(args)


if __name__ == '__main__':
    main()
